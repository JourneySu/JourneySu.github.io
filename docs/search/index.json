[{"categories":null,"content":"嗨！大家好，我是Hailey，歡迎來到我的部落格！\n我是個軟體工程師，喜歡不斷學習新知識，並追求技術的進步。\n這個部落格是我的學習筆記，記錄我在軟體開發和生活中的點滴收穫。\n.\n我喜歡與大自然親近，爬山和養植物是我的嗜好，\n健身也是我日常生活的一部分，最近也嘗試攀岩(抱石)，給自己一點小挑戰，\n除了技術能力要定時充電，身體和心靈也是需定時補充能量，是吧😆\n.\n期待在這裡與大家分享我的學習心得和生活趣事，並與各位一起交流、成長！\n.\n","permalink":"http://localhost:1313/about/","tags":null,"title":"About Me"},{"categories":["英文學習"],"content":"目錄\n此篇心得是由以下這個Youtube而來，\n廢話不多說，直接先上影片連結： Youtube: 輕鬆學語言，告別死讀書時代\r1、不要開啟母語字幕\n若你一直在用你的母語閱讀字幕，你可能沒有挑戰你的大腦去學習新事物\n2、找比現在程度再高一階的Level學\n3、自言自語(Self talk)\n讓自己能用新的語言去思考\n","permalink":"http://localhost:1313/posts/howtolearnenglish/","tags":["英文學習"],"title":"學英文(或任何語言)的方式"},{"categories":[],"content":"目錄\n先上我與Chatgpt的學習過程吧！\n我：\n我可以理解成，當兩個同type的變數指向同一個記憶體位置時，如\rListNode a= new ListNode(3);\rvar b = a;\r，此時更改a或b變數底下的「屬性」，改的會是指向記憶體的值，\r但若更改a或b，如\rb=b.next，則代表將原有的指向記憶體引用斷開，改成指向另一記憶體，\r所以a和b此時指向的記憶體空間便會是不一樣的，對嗎？\rChatGPT\n是的，你的理解是正確的。\r當兩個同類型的變數指向同一個記憶體位置時，它們實際上是引用相同的物件。因此，如果你更改其中一個變數底下的屬性，例如變更 a.val 或 b.val，這將影響到同一個物件，因為它們指向同一個記憶體位置。\r然而，如果你更改其中一個變數本身，例如 b = b.next;，這將會斷開這兩個變數之間的連接，使得它們指向不同的記憶體位置。在這種情況下，a 和 b 將指向不同的物件，因此它們指向的記憶體空間將不同。\r我：\n可以分別為我撰寫程式碼範例，使我更能理解嗎\rChatGPT\n當然可以，以下是一個範例程式碼：\rCopy code using System; public class ListNode { public int val; public ListNode next; public ListNode(int val=0, ListNode next=null) { this.val = val; this.next = next; } } class Program { static void Main(string[] args) { // 創建一個新的 ListNode 物件 a ListNode a = new ListNode(3); // 將 b 設置為 a ListNode b = a; // 印出 a 和 b 的 val Console.WriteLine(\u0026#34;a.val = \u0026#34; + a.val); // 3 Console.WriteLine(\u0026#34;b.val = \u0026#34; + b.val); // 3 // 更改 a 的 val a.val = 5; // 印出 a 和 b 的 val，因為 a 和 b 都指向同一個物件，所以它們的 val 都會改變 Console.WriteLine(\u0026#34;After changing a.val:\u0026#34;); Console.WriteLine(\u0026#34;a.val = \u0026#34; + a.val); // 5 Console.WriteLine(\u0026#34;b.val = \u0026#34; + b.val); // 5 // 創建一個新的 ListNode 物件 c ListNode c = new ListNode(10); // 將 b 設置為 c，這將斷開 a 和 b 之間的連接 b = c; // 印出 a 和 b 的 val，它們現在指向不同的物件，所以它們的 val 不同 Console.WriteLine(\u0026#34;After changing b:\u0026#34;); Console.WriteLine(\u0026#34;a.val = \u0026#34; + a.val); // 5 Console.WriteLine(\u0026#34;b.val = \u0026#34; + b.val); // 10 // 這裡再次更改 a 的 val a.val = 15; // 印出 a 和 b 的 val，即使 a 的 val 已經改變，但 b 不受影響，因為它們現在指向不同的物件 Console.WriteLine(\u0026#34;After changing a.val again:\u0026#34;); Console.WriteLine(\u0026#34;a.val = \u0026#34; + a.val); // 15 Console.WriteLine(\u0026#34;b.val = \u0026#34; + b.val); // 10 } } 在這個範例中，我們創建了兩個 ListNode 物件 a 和 c，並將 b 設置為 a。然後，我們更改 a 的 val，這也會影響到 b，因為它們都指向同一個物件。接著，我們將 b 設置為 c，這將斷開 a 和 b 之間的連接，使得它們指向不同的物件。最後，我們再次更改 a 的 val，但這次不會影響到 b，因為它們現在指向不同的物件。\r我\n上面同樣的例子，記憶體指向可以用圖示的方式做解釋嗎？\rChatGPT\n當然可以！讓我用圖示來解釋：\r首先，我們先來看一下一開始的情況，a 和 b 都指向同一個物件：\rListNode: a, b | v [ 3 | ] --\u0026gt; null 在這個情況下，a 和 b 都指向 [ 3 | ] 這個節點。\r接著，當我們將 b 設置為 c 時，b 將指向一個新的物件，而不是 a 所指向的物件：\rListNode: a ListNode: b | | v v [ 3 | ] --\u0026gt; null [ 10 | ] --\u0026gt; null 現在，a 和 b 指向不同的物件，分別是 [ 3 | ] 和 [ 10 | ]。\r即使我們修改了 a 所指向的物件的值，b 不會受到影響，因為它們指向不同的物件。這就是為什麼在最後一部分中，a.val 和 b.val 的值分別是 15 和 10。\r我\n是否可以你將程式碼寫出來，考我的理解程度\rChatGPT\n當然，以下是一些程式碼示例，您可以試著理解它們的執行結果：\rpublic class ListNode { public int val; public ListNode next; public ListNode(int val=0, ListNode next=null) { this.val = val; this.next = next; } } class Program { static void Main(string[] args) { // 示例 1: 值類型和參考類型的存儲方式不同 int value1 = 10; int value2 = value1; value1 = 20; Console.WriteLine(\u0026#34;value1 = \u0026#34; + value1); // 20 Console.WriteLine(\u0026#34;value2 = \u0026#34; + value2); // 10 ListNode node1 = new ListNode(3); ListNode node2 = node1; node1.val = 5; Console.WriteLine(\u0026#34;node1.val = \u0026#34; + node1.val); // 5 Console.WriteLine(\u0026#34;node2.val = \u0026#34; + node2.val); // 5 // 示例 2: 物件之間的指向關係 ListNode head = new ListNode(1); head.next = new ListNode(2); head.next.next = new ListNode(3); ListNode current = head; while (current != null) { Console.WriteLine(\u0026#34;Node value: \u0026#34; + current.val); current = current.next; } // Node value: 1 // Node value: 2 // Node value: 3 // 示例 3: 物件引用的影響 Person person1 = new Person(\u0026#34;Alice\u0026#34;); Person person2 = person1; person1.Name = \u0026#34;Bob\u0026#34;; Console.WriteLine(\u0026#34;person1.Name = \u0026#34; + person1.Name); // Bob Console.WriteLine(\u0026#34;person2.Name = \u0026#34; + person2.Name); // Bob // 示例 4: 陣列中的物件引用 int[] array1 = {1, 2, 3}; int[] array2 = array1; array1[0] = 10; Console.WriteLine(\u0026#34;array1[0] = \u0026#34; + array1[0]); // 10 Console.WriteLine(\u0026#34;array2[0] = \u0026#34; + array2[0]); // 10 } } public class Person { public string Name { get; set; } public Person(string name) { Name = name; } } 這些示例包含了值類型和參考類型的存儲方式、物件之間的指向關係以及物件引用的影響。請試著運行這些程式碼片段，觀察它們的輸出，並試著理解每個示例中變數之間的關係。\r","permalink":"http://localhost:1313/posts/csharpnote/","tags":["CSharp"],"title":"談談C#-兩個變數指向相同記憶體位址"},{"categories":["演算法","資料結構"],"content":"目錄\n科普一下 non-decreasing(非遞減)與 increasing(遞增) 是一樣的嗎？\n直接上個例子：\nnon-decreasing(非遞減) ： 1 2 3 4 or 1 1 2 3\nincreasing(遞增) ：1 2 3 4\n非遞減的意思是下一個元素不小於前一個元素，所以 1 2 3 4 or 1 1 2 3 都符合非遞減的條件，\n但只有1 2 3 4符合遞增的條件，所以兩種排序方式是有這樣的差別的。\n處理Linked-List(鏈結串列)的各種方式： Push-從尾新增節點\npop-從尾移除節點\nShift-從頭移除節點\nUnshift-從頭新增節點\nInsert-從中間新增節點\nremove-從中間移除節點\nget-取得節點資訊：類似Search\nLinked List及Array 時間複雜度比較表 思考：比較下來，發現LinkedList的優勢會在從頭新增元素時，不需像Array一樣將所有索引重新計算，但整體看下來，適合用Array的應用情境會比較多，不太確定Singly-Linked-List的重要性為何，待後面有更深入了解再補上吧。 (有可能使用方式是來做其他演算法如二元樹的基礎)\n參考資料\r","permalink":"http://localhost:1313/posts/recursion/","tags":["演算法","資料結構"],"title":"談談遞迴Recursion"},{"categories":["演算法","資料結構"],"content":"目錄\n演算法是什麼\rChatgpt提供的學習計劃\r演算法介紹\rTwo Pointer\r其他待整理key word\r資料結構\r演算法\r演算法是什麼 {待補}\nChatgpt提供的學習計劃 第一階段：建立基礎\r1. 基本概念\r- 學習演算法和資料結構的基本概念，例如陣列、鏈表、堆疊、佇列等。\r2. 時間複雜度和空間複雜度\r- 理解演算法的時間複雜度和空間複雜度，並學習如何評估演算法的效能。\r3. 排序演算法\r- 學習常見的排序演算法，如冒泡排序、插入排序、選擇排序、快速排序、合併排序等。\r4. 搜尋演算法\r- 瞭解搜尋演算法，包括線性搜尋和二分搜尋。\r第二階段：擴展知識\r1. 圖論\r- 學習圖論相關的基本概念，如圖、路徑、迴路、最短路徑等，以及常見的圖論演算法，如深度優先搜索（DFS）和廣度優先搜索（BFS）。\r2. 動態規劃\r- 瞭解動態規劃的基本原理和應用場景，並學習如何設計動態規劃演算法解決問題。\r3. 貪婪演算法\r- 學習貪婪演算法的基本原理和常見應用，以及貪婪演算法與動態規劃的區別和適用場景。\r第三階段：實際應用\r1. 演算法問題練習\r- 解決各種演算法問題，可以通過線上資源如 LeetCode、HackerRank、Codewars 等網站來進行練習。\r2. 專案應用\r- 在你的 ASP.NET Core 專案中實際應用所學的演算法知識，優化程式碼效能，處理複雜的邏輯問題。 演算法介紹 Two Pointer 其他待整理key word 資料結構 電腦區分兩種方法： 大塊：Array 小塊：Linked List 連結數量 一個連一個\u0026mdash;\u0026gt;Linked List(鏈結串列) 一個連兩個\u0026mdash;\u0026gt;Binary tree(二元樹) 一個連多個\u0026mdash;\u0026gt;B-Tree 或 B+ Tree(多元樹) 存放位置 通常存放在記憶體：Linked List、Binary tree 通常存放在硬碟：B-Tree Hash Table(雜湊表)：\n混合大塊和小塊的結構，也就是rray當大容器，每一格當中都可以放一個Linked List。至於每個東西要放哪一格，就是由雜湊函數來決定！ 演算法 排序 + 二分搜尋法：用來加快Arry的搜尋速度 雜湊函數(不確定是否歸類在演算法) 按方法分類 先讀書培養與鍛鍊程式設計的邏輯腦-程式設計大賫的解題策略基礎入門再補上一些以下方法，就差不多夠了。\n遞增法 Incremental Method 記憶法 Memoization 枚舉法 Enumerative Method 遞推法 Iterative Method 遞歸法 Recrusive Method 分治法 Divide and Conquer 動態規劃 Dynamic Programming 貪心法 Greedy Method 縮放法 Scaling Method 套用模型 Modeling ","permalink":"http://localhost:1313/posts/algorithm/","tags":["演算法","資料結構"],"title":"資料結構及演算法學習筆記"},{"categories":["Hugo"],"content":"目錄\n常用指令\r那些我踩的坑\r我明明刪除了文章，為什麼輸入url還是可以進入該網址閱讀？\r常用指令 建置\nhugo\r建置，並在local host預覽網站(預設網址:http://localhost:1313/)\nhugo server 那些我踩的坑 我明明刪除了文章，為什麼輸入url還是可以進入該網址閱讀？ 原因：當您使用 hugo server 命令運行 Hugo 伺服器時，Hugo 不會自動清理 public 目錄中的內容。\n解決： 要清理已經生成的內容，您可以在執行 hugo 命令之前手動清空 public 目錄，或者在建置時加入以下參數。\n該參數告訴 Hugo 在生成網站之前清理 public 目錄歐\nhugo --cleanDestinationDir\rhugo server --cleanDestinationDir\r","permalink":"http://localhost:1313/posts/bundlepage/","tags":["Hugo"],"title":"Hugo BundlePage"},{"categories":["演算法","資料結構"],"content":"目錄\nChatgpt提供的學習計劃\rH1\rH2\rH3\rH4\rH5\rH6\rChatgpt提供的學習計劃 Chatgpt提供的學習計劃 H1 H2 H3 H4 H5 H6 斜體字\n斜體字2\n粗體字\n斜體兼粗體\n斜體兼粗體2\n刪除線\n正常上標\n19^th^ 上標\nH~2~O 下標\n++底線++\n底線\n==螢光標記== 要變紅色的文字放這裡\n目錄不顯示此標題 引言\n第一層\n第二層\n第三層\n另一種區塊\n另一種區塊 另一種區塊 另一種區塊\r清單(無序)\nRed Green Blue Red Green Blue Red Green Blue 清單(有序)\nBird McHale Parish Checkbox\nuncheck check 分隔線(但目前的Hugo theme顯示不出來…)\n程式碼 短區塊程式碼 短區塊程式碼\n連結 連結名稱\r標籤連結 Google\rYahoo\rMSN\r圖片 游標顯示\r表格\n欄位1 欄位2 欄位3 置左 置右 置中 姓名 地址 曉明 aaaaaaaaaaaaa 阿志 bbbbbb 姓名 地址 曉明 aaaaaaaaaaaaa 陳阿志 bbbbbb 表情圖案 :smile: 😃\n","permalink":"http://localhost:1313/posts/posttemplate/","tags":["演算法","資料結構"],"title":"文章模板(開發用)"}]